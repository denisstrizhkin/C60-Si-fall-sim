### init ###
units metal
dimension 3
boundary p p m
atom_style atomic
atom_modify map yes

read_data ${input_file}
balance 1.0 shift xyz 10 1.0

### variables ###
variable fixed_width equal '0.5 * v_lattice'
variable bath_floor_top equal 'zlo + 1 + v_fixed_width'
variable Si_fixed_top equal 'zlo + v_fixed_width'
variable C60_z equal 'v_C60_z_offset + v_Si_top'
variable C60_vel equal '-sqrt(v_energy * 1000) * 5.174 '

### regions ###
lattice diamond ${lattice} orient x 1 0 0 orient y 0 1 0 orient z 0 0 1

# region Si_fixed_floor   block EDGE                   EDGE                   EDGE                   EDGE                   EDGE ${Si_fixed_top} units box
# region Si_fixed_x_left  block EDGE                   $(xlo + v_fixed_width) EDGE                   EDGE                   EDGE ${Si_top} units box
# region Si_fixed_x_right block $(xhi - v_fixed_width) EDGE                   EDGE                   EDGE                   EDGE ${Si_top} units box
# region Si_fixed_y_left  block EDGE                   EDGE                   EDGE                   $(ylo + v_fixed_width) EDGE ${Si_top} units box
# region Si_fixed_y_right block EDGE                   EDGE                   $(yhi - v_fixed_width) EDGE                   EDGE ${Si_top} units box
# region Si_fixed         union 5 Si_fixed_floor Si_fixed_x_left Si_fixed_x_right Si_fixed_y_left Si_fixed_y_right
#
# region floor   block EDGE                          EDGE                          EDGE                          EDGE                          ${Si_fixed_top} $(v_Si_fixed_top + zlat) units box
# region x_left  block EDGE                          $(xlo + xlat + v_fixed_width) EDGE                          EDGE                          ${Si_fixed_top} ${Si_top}              units box
# region x_right block $(xhi - xlat - v_fixed_width) EDGE                          EDGE                          EDGE                          ${Si_fixed_top} ${Si_top}              units box
# region y_left  block EDGE                          EDGE                          EDGE                          $(ylo + ylat + v_fixed_width) ${Si_fixed_top} ${Si_top}              units box
# region y_right block EDGE                          EDGE                          $(yhi - ylat - v_fixed_width) EDGE                          ${Si_fixed_top} ${Si_top}              units box

region e_stop block EDGE EDGE EDGE EDGE EDGE $(v_zero_lvl + 5) units box
region dt_reset block EDGE EDGE EDGE EDGE EDGE $(v_zero_lvl + 30) units box

region Si_fixed block EDGE EDGE EDGE EDGE EDGE ${Si_fixed_top} units box

region floor   block EDGE          EDGE          EDGE          EDGE          ${Si_fixed_top} ${bath_floor_top} units box
region x_left  block EDGE          $(xlo + xlat) EDGE          EDGE          ${Si_fixed_top} ${Si_top}         units box
region x_right block $(xhi - xlat) EDGE          EDGE          EDGE          ${Si_fixed_top} ${Si_top}         units box
region y_left  block EDGE          EDGE          EDGE          $(ylo + ylat) ${Si_fixed_top} ${Si_top}         units box
region y_right block EDGE          EDGE          $(yhi - ylat) EDGE          ${Si_fixed_top} ${Si_top}         units box
region bath union 5 floor x_right x_left y_right y_left

region C60_box block EDGE EDGE EDGE EDGE $(v_C60_z - 10) EDGE units box

region clusters block EDGE EDGE EDGE EDGE 0 INF units box

write_restart ${vacs_restart_file}


### potentials ###

pair_style tersoff/zbl
pair_coeff * * SiC.tersoff.zbl Si C
neigh_modify every 1 delay 0 check no
neigh_modify binsize 5
neigh_modify one 4000

# pair_style  hybrid airebo 3.0 tersoff/zbl
# pair_coeff  * * tersoff/zbl SiC.tersoff.zbl Si C
# pair_coeff  2 2 none
# pair_coeff  * * airebo CH.airebo NULL C
# neighbor    3.0 bin


### C60 molecule ###
molecule C60 ${mol_file}
create_atoms 1 single ${C60_x} ${C60_y} ${C60_z} mol C60 1 units box
group C60 region C60_box


### groups ###
group C type 2
group Si type 1

group Si_fixed region Si_fixed
group nve subtract all Si_fixed
group thermostat dynamic Si region bath every 1

group dt_reset dynamic all region dt_reset every 100


### computes ###

# compute ke per atom
compute atom_ke all ke/atom

#temp
#variable zero_lvl equal "83.2"

# voronoi
compute voro_occupation Si voronoi/atom occupation only_group
variable is_vacancy atom "c_voro_occupation[1]==0"
variable vacancy_id atom "v_is_vacancy*id"
compute vacancies Si reduce sum v_is_vacancy

# sputtered atoms
variable is_sputtered atom "z>v_zero_lvl"
compute sputter_all all reduce sum v_is_sputtered
compute sputter_si  Si  reduce sum v_is_sputtered
compute sputter_c   C   reduce sum v_is_sputtered


### thermo ###
reset_timestep 0
timestep ${step}
thermo 10
thermo_style custom step pe ke etotal temp c_vacancies dt time c_sputter_all c_sputter_c c_sputter_si


### fixes ###
fix balance all balance 20 1.0 shift xyz 10 1.0
fix nve nve nve
fix tbath thermostat temp/berendsen ${temperature} ${temperature} 0.001
fix estop all electron/stopping 10.0 ${elstop_table} region e_stop
fix dt dt_reset dt/reset 1 $(v_step/2) ${step} 0.1


### dumps ###
# dump during all custom 10 ${dump_during} id type x y z c_atom_ke


### run simulation ###
velocity C60 set NULL NULL ${C60_vel} sum yes units box

#fix temp_time all print 10 "$(time) $(temp)" file {run_dir}/temp_time.txt screen no
#fix penrg_time all print 10 "$(time) $(pe)" file {run_dir}/penrg_time.txt screen no

label run_a
run 100
if "$(time) < 1" then "jump SELF run_a"

unfix estop
unfix dt_reset
group dt_reset delete

# label run_b
# run 200
# if "$(time) < $(v_run_time / 1000)" then "jump SELF run_b"
run ${run_time}
 
group clusters variable is_sputtered
compute clusters all cluster/atom 3
compute mass clusters property/atom mass

dump clusters clusters custom 1 ${dump_cluster} id x y z vx vy vz type c_mass c_clusters c_atom_ke
dump final all custom 1 ${dump_final} id x y z vx vy vz type c_clusters c_atom_ke

run 0

undump clusters
undump final

# fix tbath nve temp/berendsen ${temperature} ${temperature} 0.001
# run 1000 
#
# unfix tbath
# fix tbath thermostat temp/berendsen ${temperature} ${temperature} 0.001
# run 1000

group vac variable is_vacancy static
write_dump vac custom ${dump_crater_id} id

write_data ${write_file}
